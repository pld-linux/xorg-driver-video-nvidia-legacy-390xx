--- NVIDIA-Linux-x86_64-390.116-no-compat32/kernel/nvidia-uvm/uvm8.c.orig	2019-01-27 17:12:22.000000000 +0100
+++ NVIDIA-Linux-x86_64-390.116-no-compat32/kernel/nvidia-uvm/uvm8.c	2019-05-07 20:36:42.676844249 +0200
@@ -166,13 +166,21 @@
 // If a fault handler is not set, paths like handle_pte_fault in older kernels
 // assume the memory is anonymous. That would make debugging this failure harder
 // so we force it to fail instead.
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
+static vm_fault_t uvm_vm_fault_sigbus(struct vm_area_struct *vma, struct vm_fault *vmf)
+#else
 static int uvm_vm_fault_sigbus(struct vm_area_struct *vma, struct vm_fault *vmf)
+#endif
 {
     UVM_DBG_PRINT_RL("Fault to address 0x%lx in disabled vma\n", nv_page_fault_va(vmf));
     return VM_FAULT_SIGBUS;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
+static vm_fault_t uvm_vm_fault_sigbus_wrapper(struct vm_fault *vmf)
+#else
 static int uvm_vm_fault_sigbus_wrapper(struct vm_fault *vmf)
+#endif
 {
 #if defined(NV_VM_OPS_FAULT_REMOVED_VMA_ARG)
     return uvm_vm_fault_sigbus(vmf->vma, vmf);
@@ -507,7 +515,11 @@
     }
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
+static vm_fault_t uvm_vm_fault_wrapper(struct vm_fault *vmf)
+#else
 static int uvm_vm_fault_wrapper(struct vm_fault *vmf)
+#endif
 {
 #if defined(NV_VM_OPS_FAULT_REMOVED_VMA_ARG)
     return uvm_vm_fault(vmf->vma, vmf);
